---
title: "Kaigi on Rails 2022で登壇しました"
date: "2022-10-23 12:10:47"
---

10月21日、22日に開催されたKaigi on Rails 2022にSpeakerとして登壇しました！

https://kaigionrails.org/2022/

初のカンファレンス登壇で順番最後、かつギリギリまで準備が終わらず、最後の最後までずっとソワソワして参加者としてはガッツリは参加できなかった（アーカイブ見るぞ）のですが、とてもいい経験ができました！運営の皆さん本当にありがとうございました！

登壇資料はこちらです！

https://speakerdeck.com/ikumatadokoro/zi-fen-dakenoxiao-sanaselenium-olenium-wozuo-tuteshi-meru-burauzazi-dong-hua-ji-shu-noli-lun-toshi-jian

せっかくなので自分の発表についてつらつらと書いていきたいと思います。
（現状ブログに目次機能がないので見づらくてすみません😅）

---
- 登壇へのモチベーション
- 登壇テーマの選定
- 準備
  - 実際にWebDriverやCDPを読んでいく
  - chromedp/pdlgenの実装を読むのが大変だった
  - 実装：Olaywrightの実装で頭ごっちゃに
  - 実装：Gem使うかどうか
  - なんでirbで動かすことにしたの？
  - Olaywright.usage
- 資料作成
  - カラーパレットとコンポーネント
  - フォント
  - コード部分
  - 表紙について
- 発表練習
- 感想
- 謝辞
---


## 登壇へのモチベーション

スライドにもあるとおり、FJORD BOOT CAMPでの学習期間を経て、今年の6月からエンジニアとして働き始めています。

https://bootcamp.fjord.jp/

で、やっぱりエンジニアになったからにはカンファレンスとか登壇してみたいわけですね。学び初めの時は「地域rbに顔出すのは上級者」くらいの気持ちだった人がそう思っているのは、完全にFJORD BOOT CAMPにいた影響だと思っています。

なんか知っている人結構いるし、卒業生の中からRubyKaigiに登壇している人もいるし、じぶんもやってみたい！と自然に思えるようになっていました。

## 登壇テーマの選定

今回はブラウザ自動化技術を登壇テーマに選んだんですが、理由としては2つありました。

1. ブラウザ自動化を便利に使っていたが、その中身はよく知らないままだなと思っていたので、その中身を知りたかった
2. もともとブラウザ自体に興味があった

1つ目は発表にあった通りで、2つ目についてはWebアプリを作る以上ブラウザに載せることがほとんどなので、そこをちゃんと知りたいなあという思いです。

昨今ではCSSフレームワークとかもよくできているので、見栄え的にはあまり考えなくてもまあまあ綺麗なものができるのですが、でももうちょっとブラウザ自体を知らないとブラウザの真価を発揮したりとかセキュリティ意識したりとかいろんな環境を意識して作るとかできないよなあと。

動きを把握する時にはやっぱり実際に動きが始まるところから見るのがわかりやすいと思うのですが、ブラウザ自動化は自分が知っている領域でもあり、ブラウザに対するエントリポイント的な位置付けなので、今回はここにフォーカスしようという気持ちもありました。

近いうちに簡易なレンダリングエンジン実装とかやってみたいですね（OlelinkとかOleKitとかですかねえ）


## 準備

### 実際にWebDriverやCDPを読んでいく

発表ではわりとさっくり「意外とシンプルに接続できる」という流れで紹介していましたが、当然のごとくミリしら状態で仕様を見始めたので、なかなかうまくいかず苦労しました。

資料の中で「Capabilities」や「WebSocket」が用語で1ページとってありますが、これは実際に試している中で「なんだこれ」とか「いまいちわからん」と詰まった箇所です（ActionCableちゃんと使ったことないのがバレた）。

例えばWebSocketの接続をする際にもWebSocket自体の理解が曖昧で、最初は色々と回りくどい方法でURLを取得していたのですが、RubyのCDPクライアントferrumのソースを読んでいる中で「あ、サブプロセスで起動したChromeの標準出力を正規表現で抽出して、WebSocketのURL取得しているじゃん、これでええやん」と理解し、発表のような説明となりました。先人偉大なり。

https://github.com/rubycdp/ferrum/blob/efb6f2035c442582e815328e633d1f1d6c97e456/lib/ferrum/browser/process.rb#L99-L102

大変といえば大変だったんですが、その分色々と自分が知らない知識も増えて面白かったです。例えば上記箇所だとObjectSpace.define_finalizerを知ることができました（一人igaigaふむふむタイム）。

https://twitter.com/igaiga555/status/1569154474060705792

https://zenn.dev/igaiga/books/rails-practice-note/viewer/ruby_debugging#objectspace%23finalizer

### chromedp/pdlgenの実装を読むのが大変だった

なにが大変だったって、Goの文法を一切知らない状態から始めたのもあるんですが、chromedpでCDPをパースしているライブラリの最新ブランチがmasterじゃなくてoldだったことなんですよね😅

自分のローカルにCloneしてchromedp/pdlgenを実行した時にpanicになって落ちてしまいました。
Goの知識が乏しく「自分の環境が悪いってことかな」と思って何日か文法調べつつ読んでいき、最終的に一部分岐で落ちていることがわかったため、Issueで報告しようとしたタイミングで同じ事象のIssueがあることに気が付き...

https://github.com/chromedp/pdlgen/issues/16

> I guess its required to use the old branch?

> Yes, the old branch is the latest branch.

oldブランチにしたら動きました😅

### 実装：Olaywrightの実装で頭ごっちゃに

CFP提出時点でOleniumは動くものができていたので、上記の調べ物をしたのち、Olaywrightの実装に取り掛かりました。

が、この辺りで「フロントエンドエンジニア」となったため、仕事前にはRuby書いて業務中はTypeScriptだけ書いてて、仕事終わったらRuby書いて...となり、地味に大変でした。マジで何回constで変数定義して、constがなくて怒られたと思っているんだ？（===もめっちゃやったなあ）

まあそれくらいならまだいいんですが、オブジェクトに対する考え方が完全にJavaScriptに引っ張られていたのが一番大変でした。今回の発表ではJSONをパースして、Rubyのメソッドとして呼び出せるようにしていましたが、そこです。

縛りなしで、個人的にもっとも実行しやすいインターフェースを考えると、たとえばTarget.createTargetというCDPのメソッドは`target.create_target(url: 'https://google.com')`という形で呼べるのがRubyっぽくかつシンプルで分かりやすいと考えました。

で、これを静的に定義しておこうと思ったところで頭がこんがらがります。

- Chromeへのメソッド実行は、実際のところメソッド名をただメッセージに渡すだけ。つまりメソッドの中身がないので、わざわざあらかじめ定義しておく意味があまりない。
- JSONで落ちてきたCDPには、そのメソッドに関する説明が多分に入っており、それをすべて削除するような構造になってしまう。
`target.create_target()`がメソッドだとすると、CDPでやってくる「Target.createTargetの説明」や「Target.createTargetはexperimentalかどうか」といった情報を`target.create_target.description`、`target.create_target.experimental?`のように持たせるのが難しい（私がわからなかっただけなので、できたらどこかで教えてください〜〜！）

さらにめんどうなことに

- Goの方読んでたら構造体が出てきてクラスが歪み始める
- 一日の大半はTypeScriptを書いているので、またまたオブジェクトに対する認知が歪み始める

となり、かなりの日数手が止まったあげく最終的には以下のような方針・実装になりました。

- やっぱり`target.create_target.description`とか`target.create_target.experimental?`とか呼び出せると嬉しい（なおbooleanを返すメソッドにはRubyライクに「?」つけたかったのですが、忘れていたので実際のコードではやっていないです。）
- WebSocketへメッセージを送信する部分以外は振る舞いではなく、単なる情報（説明とか実験的機能だとか任意のパラメータだとか）の集まりなので、Structでいいんでは？
- JSのFunctionオブジェクト的な感じで格納できればなおのことよかったんだけど、それはRubyではできない（？）ので、Structのプロパティの中で他の情報と並列に`exec`というプロパティを保持し、ここにProcオブジェクトを持たせる形で定義する
  - Sturctのメソッドとして定義すりゃよかったんですが、Chromeクラスで持っているWebSocketの接続情報のコンテキストを渡すのがさっとできなかったので、呼び出しがProcの呼び出し（`exec[]`）になったわけです。
- 愚直によぶと`browser.domains.page.navigate.exec[url: 'https://google.com']`のような長さになる。これは嫌だ。
- というわけで最終的に必要なDomainの情報を一行パターンマッチでキャプチャすりゃあええやろ（`chrome.domains in { page: }`）

https://gist.github.com/IkumaTadokoro/26e08130f849c9aac8c4b18a1adc7561

かなり頭の中で考えるのに時間を使ってしまって、ちょっと前髪整えますねくらいのリファクタリングはしたんですが、そこまでで力尽きてインスタンス生成に3秒かかるプログラムになりました💦 どう考えてもループしすぎですね、どうもありがとうございました。

### 実装：Gem使うかどうか

`String#underscore`をrefinementで拡張しているところとか別にActiveSupport入れてもよかったんですが、ライブラリ使わないでもRuby本体だけで欲しいもの書けるんだ！っていう思いも発表にこめたかったので自前で定義しています（発表では見せませんが）。

じゃあなんでWebSocketはライブラリを使っているかというと、このGemの管理を現在やっているのが運営のうなすけさんだったので、何か選考に有利に働いてくれないかなあと思い、CFPの時点でこのGemを使うということを明記したという経緯でした笑

https://rubygems.org/gems/websocket-client-simple

名前の通りめちゃくちゃシンプルでコードも読みやすいので、想定聴者がジュニア〜中級くらいのこの発表の筋にもあっている気がして、WebSocketの中でもこのGemにしたというのもあります。

websocket-client-simpleのコードを読む過程でEventEmitterについて知り、一人ターミナルチャットアプリやってました。勉強にはなりましたが寂しかったです。

### なんでirbで動かすことにしたの？

苦肉の策で上記の通り多段Structをやった結果、Olenium同様にスクリプトを書いても全然補完が走らず、これはどうしたものかと思ったところ、「irb上でインスタンス化した後なら補完走るじゃん！！」と思い立ちこうなりました。いやあirb便利。

ちなみに補完が走る際に、Structではセッターの方のメソッドも補完が走ります。これはスクリプトを動かす際には使わないのでどうにか消したかったんですが（freezeはしているけど）やり方わからず断念しました（Structのサブクラスに対して、[これ](https://docs.ruby-lang.org/ja/latest/function/remove_method.html)呼べないですよね？できるのであれば教えてほしいです〜〜）。

### Olaywright.usage

こうやって作っていく上でもうPlaywrightの面影なぞ全くないに等しかったので、もう好き勝手やろうと思って追加しました。

```ruby
def self.usage
  puts <<~USAGE
    ○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●
       ____  __                          _       __    __
      / __ \/ /___ ___  ___      _______(_)___ _/ /_  / /_
     / / / / / __ `/ / / / | /| / / ___/ / __ `/ __ \/ __/
    / /_/ / / /_/ / /_/ /| |/ |/ / /  / / /_/ / / / / /_
    \____/_/\__,_/\__, / |__/|__/_/  /_/\__, /_/ /_/\__/
                /____/                /____/
    ○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●○●
    ┌─────────────────────────┐
    │   What is Olaywright?   ├────────────────────────────┐
    └┬────────────────────────┘                            │
     │  "Ole no" Playwright.                               │
     └─────────────────────────────────────────────────────┘
    ┌─────────────────────────┐
    │       Basic Usage       ├────────────────────────────┐
    └┬────────────────────────┘                            │
     │ # Setup                                             │
     │ browser = Olaywright.new                            │
     │ browser.domains in { page:, target: }               │
     │                                                     │
     │ # Exec Command ex) Target.createTarget              │
     │ # Notice: Use snake_case. You're in Ruby world.     │
     │ target.create_target.exec[url: 'https://google.com']│
     └─────────────────────────────────────────────────────┘
  USAGE
end
```

これはMonodrawというツールで描いてみました。

https://monodraw.helftone.com/

GitHubの人がER図をアスキーアートで書いてコミットメッセージに貼ることがあるという記事を見かけて、なるほどお！と思ったのをきっかけにインストールし全然違うきっかけで使ってしまいました。非常に便利なので今後も活躍しそうです。

## 資料作成

今回の資料、再掲部分も結構ありますが、合計で78枚となっています。自己最多量です。

### カラーパレットとコンポーネント

作成はFigmaで行なっていたのですが、調査とか実装が煮詰まった時にカラーパレットとコンポーネントを作成していたのが、直前になって非常に役に立ちました。

![](/assets/kaigi-on-rails-2022/figma.png)

今回は背景色に真っ白を選択しました。今年のKaigi on Railsのテーマカラーが大人ダークな色だったので、Youtubeに載せた時に画面共有の枠が目立つように白にしたという感じです。

### フォント

フォントに関しては今回は3種類をミックスしていて

- Noto Sans JP
- New Rodin Pro
- Montserrat

を使用しています。これまではコーポレートロゴver2とかラグランパンチとか奇抜なフォントを使っていたのですが、今回は時間も長いのとカンファレンスなので、読みやすいフォントにしました。

### コード部分

コードを掲載する部分も結構あったのですが、これにはFigmaのCode Syntax Highlighterプラグインを使用しています。

https://www.figma.com/community/plugin/938793197191698232

生成されたものをちょっとだけ加工して、角丸を作ったりしています。

### 表紙について

あと、最後にほんとどうでもいいところなのですが、表紙に載っている丸は実は点字になっています。

![](/assets/kaigi-on-rails-2022/さむねいる.png)

## 発表練習

資料ができたのが、本番二日前の遅い時間だったので、通しでの練習を始めたのは発表の前日。そのため、1日目は要所要所でしか発表が聞けず残念でした🥲

今回すごい当たり前のことに気がついたんですが、30分の登壇って通しで練習すると30分かかるんですよ...。なので2回練習すると1時間とぶ。
なので、セクションごとに目標時間決めて各セクション単位で練習し、早口で喋ればぎりぎり時間内におわることは計測できたので、2日目は普通に楽しみました。

本番の時間オーバーだけは避けなければならなかったので、とにかく「とまるんじゃねえぞ」で早口でしゃべっていたらなんと巻きで終わりました。あらら笑

## 感想

初チャレンジのCFP提出と登壇、本当にやってみてよかったです！CFPを出すこと自体も勉強になりましたし、カンファレンスで話すというのがどういう準備が必要なのかというのも今回知ることができました。

なにより、30分間人前で話すために業務とは直接関係ない知識をじっくり読み解いていき、それを自分の言葉に落とし込んでいく過程を締切つきでやれたのがよかったです！

今は仕事でRuby書いていないですが、今後もRuby関連のイベントには参加していきたいと思いますし、あとは今回カンファレンス登壇をさせていただいた経験を糧にフロントエンド関連のカンファレンスも登壇挑戦していきたいなと思っています。

## 謝辞

今回CFPを出すのも初めてだったので、チーフオーガナイザーの大倉さんにはGrow.rbを通じて2回相談にのっていただきました。一回目の時にはまだテーマも決まっていない状態で、二回目の時には技術トークとソフトトークをどれくらいの割合にするかの方向性についてなど相談させていただきました。

当初は自分の発表で30分も話すのは...と思っていたのですが、「話したいことがあるなら30分でもいいと思う」とアドバイスをいただけたおかげで今回の発表につなげることができました。

この一回目のGrow.rbではうなすけさん、ima1zumiさんに実際にRubyKaigiに提出したCFPを見せていただき、どういうふうにCFPを書いていくべきかについて非常に参考にさせていただきました。おかげさまでしっかりとCFPを書ききることができました。

会社の開発チームの方もCFP提出前にレビューいただきありがとうございました！

---

運営の皆さんも準備から当日までありがとうございました🙇‍♂️ 来年はハイブリッド開催とのことで非常に楽しみです！ではでは！