---
title: "Make Impossible States Impossibleを意識してPropsを設計する"
description: "UIを構成するReactコンポーネントのProps設計の際に使える指針に「Make Impossible States Impossible」という考え方があります。出典は諸説ありますが、「存在しえない状態が構成されないように、APIインターフェイスを定義する」という考えです。この考え方のもと、堅牢なReactコンポーネントを構築する方法を考察しました。"
publishDate: 2024-11-11
tags: ["React", "設計", "UI"]
draft: true
---

## Make Impossible States Impossible あるいは Make Illegal States Unrepresentable

### どのような考え方か

「Make Impossible State Impossible」とは、存在しえない状態が構成されないように、APIインターフェイスを定義するという考え方です。

私がはじめてこの考え方に出会ったのは、Production Ready GraphQLの中の一節でした。

```graphql
type Cart {
  paid: Boolean
  amountPaid: Money
  items: [CartItem!]!
}
```

上記のGraphQLスキーマは、ショッピングカートの状態を表すもので、`items`がカート内の商品、`paid`が支払い済みであるかどうか、`amountPaid`が支払い金額を表します。

このスキーマは次の2つの **「ありえない状態」** を表現できてしまうという点で問題があります。

- 支払い済みなのに支払い金額が存在しない状態（`paid`が`true`であるにもかかわらず、`amountPaid`が`null`である）
- 未払いなのに支払い金額が存在する状態（`paid`が`false`であるにもかかわらず、`amountPaid`が`null`でない）

本書の例の中では、正解は実際のユースケースによるとしつつも、一例として次のようなスキーマを提案しています。

```graphql
type Cart {
  # 支払いがあるかないか（nullable）
  payment: Payment
  items: [CartItem!]!
}

type Payment {
  paid: Boolean!
  amountPaid: Money!
}
```

これでも`paid`が`false`で、`amountPaid`が1以上のケースは防ぐことはできませんが、支払い自体は`payment`によって制御されることになったので、`null`による不整合の可能性は排除されました（`payment`で制御するのだから、`paid`は無くしてしまうのが良いと思っています）。

Make Impossible State Impossibleは、このように「ありえない状態」を排除することで、コードの堅牢性を高めるための考え方です。

### 考え方のポイントと使い所

単一のプロパティによって制御できる値に対しては、あまり不整合な状態が入り込む余地がありません。

```ts
// 有効・無効の2つの状態のみなので、考慮すべき事項は少ない
type Enabled = boolean;

// 3つの値であっても、どれか1つしか指定できないので不整合な状態は混入しづらい
type Signal = "red" | "yellow" | "green";
```

反対に複数のプロパティで定義される場合、不整合な状態が入り込みやすいです。

```ts
type ButtonProps = {
  isLoading: boolean;
  isUploading: boolean;
};
```

### 複雑な状態が抱える課題

「状態」という言葉を使っていますが、UIのパターンといった方がわかりやすいかもしれません。

代表的なものは[UI Stack](https://www.scotthurff.com/posts/why-your-user-interface-is-awkward-youre-ignoring-the-ui-stack/)に列挙されている「エラー」や「ローディング」、「エンプティ」などですが、大小含めると数多くのパターンが存在します。

### インターフェイスレベルで「ありえない」状態を排除する

### どんなときに適用できる考え方か

単一のプロパティの場合は組み合わせが少ないため、状態の組み合わせが複雑になることは少ないですが、複数のプロパティを持つ場合は組み合わせが増えるため、この考え方を適用することで、状態の組み合わせを制限することができます。

## 実践

### かんたんな事例で適用する

まずはかんたんな事例から見てみましょう。

Kent C.Dodds氏のブログからの引用になりますが、「success」「warning」「error」の3種類のスタイルを持つ`Alert`コンポーネントを実装することを考えます。

```tsx
<Alert success>登録に成功しました</Alert>
<Alert warning>一部登録に失敗したデータがあります</Alert>
<Alert error>登録に失敗しました</Alert>
```

これらの例は一見問題なさそうですが、`success`、`warning`、`error`の3つのプロパティを同時に指定することができてしまいます。

```tsx
// どのスタイルが最強の優先度を持つか勝負だ！
<Alert success warning error>登録に成功しました</Alert>
```

UIとしてはこれら3つの状態が混在することはないと仮定すると、このような状態は存在しえないはずです。このような状態を排除するために、`success`、`warning`、`error`の3つのプロパティを排他的に扱うように設計することができます。

```tsx
type AlertProps = {
  // variantをUnionで定義することで、いずれか1つのプロパティしか指定できないようにする
  variant: 'success' | 'warning' | 'error';
  children: React.ReactNode;
};
```

これにより、`success`、`warning`、`error`の3つのプロパティを同時に指定することができなくなります。

```tsx
<Alert variant="success">登録に成功しました</Alert>
```

---

実際にはUIライブラリ側で担保されていたり、それ由来で一種のパターンとして確立していることにより、独自実装であっても単一のプロパティで状態を混在させるケースはあまりないように思います。

### Propsを複雑にする前に、まずはCompositionによる責務の分離を

### オブジェクト内のプロパティを排他にする


## （Appendix）関連するライブラリ

この記事では型の定義やReactコンポーネントそのものの粒度から「Make Impossible State Impossible」について考えました。世の中にはそれ以外の方法でこの考えを表現しているTypeScriptライブラリがあるので、参考までに紹介します。

### X State

### Zag.js

### fp-ts
