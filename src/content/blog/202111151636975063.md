---
author: ikuma-t
publishDate: 2021-11-15 20:17:43
modDatetime: 2021-11-15 20:17:43
title: "RubyMine2021.2.3でdocker compose環境のRailsを動かしてみる"
slug: "202111151636975063"
featured: false
draft: false
tags:
  - PROGRAMMING
  - Ruby on Rails
  - RubyMine
  - Docker
description: "RubyMine2021.2.3でdocker compose環境のRailsを動かしてみる"
---

## 動機

昨今の開発において、常識になっているDocker。

私もそろそろ学ばねばということで、書籍を使って概要を掴みました。

[![仕組みと使い方がわかる Docker＆Kubernetesのきほんのきほん (Compass Booksシリーズ)](https://m.media-amazon.com/images/I/51vhRrY-JEL._SL500_.jpg "仕組みと使い方がわかる Docker＆Kubernetesのきほんのきほん (Compass Booksシリーズ)")](https://www.amazon.co.jp/exec/obidos/ASIN/B08T961HKP/hatena-blog-22/)

[仕組みと使い方がわかる Docker＆Kubernetesのきほんのきほん (Compass Booksシリーズ)](https://www.amazon.co.jp/exec/obidos/ASIN/B08T961HKP/hatena-blog-22/)

- 作者:[小笠原 種高](http://d.hatena.ne.jp/keyword/%BE%AE%B3%DE%B8%B6%20%BC%EF%B9%E2)
- [マイナビ出版](http://d.hatena.ne.jp/keyword/%A5%DE%A5%A4%A5%CA%A5%D3%BD%D0%C8%C7)

[Amazon](https://www.amazon.co.jp/exec/obidos/ASIN/B08T961HKP/hatena-blog-22/)

Dockerの仕組み、Dockerfile、Docker Composeの基本はわかったけれど、実際に[Rails](http://d.hatena.ne.jp/keyword/Rails)アプリを動かしてみたらどうなるんだろう？と気になっていたところ、RubyMineの公式がDocker Compose環境で[Rails](http://d.hatena.ne.jp/keyword/Rails)を動かすサンプル[リポジトリ](http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA)を公開していたので、[Rails](http://d.hatena.ne.jp/keyword/Rails)アプリの起動までやってみました。

## やること

[チュートリアル: リモートインタープリターとしての Docker Compose | RubyMine](https://pleiades.io/help/ruby/using-docker-compose-as-a-remote-interpreter.html)をやる

サンプル[リポジトリ](http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA)：

<iframe src="https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2FJetBrains%2Fsample_rails_app" title="GitHub - JetBrains/sample_rails_app: The main sample app for the Ruby on Rails Tutorial, 6th Edition" class="embed-card embed-webcard" scrolling="no" frameborder="0" style="display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;"></iframe>

> [github.com](https://github.com/JetBrains/sample_rails_app)

## やってみる

### まずはgit clone

<img alt="f:id:ikmbear:20211115164149p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115164149.png" title="" height="96" width="916" />

<img alt="f:id:ikmbear:20211115164102p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115164102.png" title="" height="712" width="912" />

コマンドでも構いませんが、RubyMineを使用しているので、「Get from [VCS](http://d.hatena.ne.jp/keyword/VCS)」からサンプル[リポジトリ](http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA)のURLを設定して、cloneを実施します。

### DB設定を[Postgresql](http://d.hatena.ne.jp/keyword/Postgresql)に変更する

cloneした時点ではDB設定がsqlite3になっているようなので、`config/database.yml`を開き、使用するDBを変更します。

<img alt="f:id:ikmbear:20211115170018p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115170018.png" title="" height="317" width="582" />

### コンテナを起動する

次に`docker-compose.yml`を開いて、ガターにある矢印アイコンを押します。

<img alt="f:id:ikmbear:20211115164929p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115164929.png" title="" height="655" width="472" />

これで`/usr/local/bin/docker-compose -f /Users/tadokoroikuma/RubymineProjects/sandbox/sample_rails_app/docker-compose.yml up -d`というコマンドが実行されます。

つまりは、この`docker-compose.yml`をベースとして、バックグラウンドでサービス（コンテナ）を起動するわけです。  
これで[Postgresql](http://d.hatena.ne.jp/keyword/Postgresql)と[Ruby](http://d.hatena.ne.jp/keyword/Ruby)のコンテナがそれぞれ作成&起動されます。

### [インタープリタ](http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%BF%A1%BC%A5%D7%A5%EA%A5%BF)ーとして、コンテナ上の[Ruby](http://d.hatena.ne.jp/keyword/Ruby)を指定する

次にRubyMineに対して、コンテナ上の[Ruby](http://d.hatena.ne.jp/keyword/Ruby)を参照するように設定します。

<img alt="f:id:ikmbear:20211115184357p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115184357.png" title="" height="708" width="969" />

Preferences \> [Ruby](http://d.hatena.ne.jp/keyword/Ruby) [SDK](http://d.hatena.ne.jp/keyword/SDK) and Gemsを開き、「+」から「New Remote」を選択します。

<img alt="f:id:ikmbear:20211115184525p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115184525.png" title="" height="416" width="720" />

<img alt="f:id:ikmbear:20211115184601p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115184601.png" title="" height="820" width="1079" />

続いて、Docker Composeのwebコンテナの[Ruby](http://d.hatena.ne.jp/keyword/Ruby)を参照するように設定し、「OK」を押します。

### DB作成と[マイグレーション](http://d.hatena.ne.jp/keyword/%A5%DE%A5%A4%A5%B0%A5%EC%A1%BC%A5%B7%A5%E7%A5%F3)を行う

次に`rails db:create`と`rails db:migrate`を実施します。  
これに限らずですが、ターミナルからコンテナに入ってコマンドを直接実行する方法と、RubyMineの機能を使って実行する方法の2種類があるので、それぞれ解説します。

**ターミナルからコンテナに入ってコマンドを直接実行する方法**

```
# webコンテナを指定してコマンドを実行する（bashを起動する）$ docker-compose exec web bash # DBの作成を行う（rails db:migrateも同様）$ rails db:createCreated database 'sample_rails_app_db'Created database 'sample_rails_app_db_test
```

**RubyMineの機能を使って実行する方法**

RubyMineのRunAnythingに包含されている、Rake Taskの実行を用いて起動します。  
（rakeタスクのコマンドは[rails](http://d.hatena.ne.jp/keyword/rails)コマンドに移管されたのですが、RubyMineの機能を使う場合は、Rakeタスクとして扱う必要があります。というか[Rails](http://d.hatena.ne.jp/keyword/Rails)コマンドで実行しても結局はRakeタスクを叩いているだけなので...）

`^`を2回押して、RunAnythingを呼び出し、`rake --tasks`と入力してEnterで実行します。

<img alt="f:id:ikmbear:20211115185948p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115185948.png" title="" height="737" width="716" />

これをしないとどうもDocker環境でRakeタスクが認識できないようで...（これは不便）。

これでRakeタスクが使えるようになったので、RunAnythingから`rake db:create`を実行します（`rake db:migrate`も同様）

<img alt="f:id:ikmbear:20211115190247p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115190247.png" title="" height="737" width="716" />

### DBが作成されたか確認する

[チュートリアル](http://d.hatena.ne.jp/keyword/%A5%C1%A5%E5%A1%BC%A5%C8%A5%EA%A5%A2%A5%EB)にはありませんが、RubyMineのDBクライアント機能を使って作成されたDBを確認してみましょう。

<img alt="f:id:ikmbear:20211115190656p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115190656.png" title="" height="777" width="652" />

まずはDatabaseツールウィンドウを開いて、「+」ボタンからDataSourceとして[PostgreSQL](http://d.hatena.ne.jp/keyword/PostgreSQL)を選択します。

<img alt="f:id:ikmbear:20211115191120p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115191120.png" title="" height="812" width="912" />

次に接続に必要な情報を以下の通り設定していきます。

| 項目           | 設定                                                         | 説明                                                                                                                            |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------- |
| Port           | 54333                                                        | docker-compose.ymlで設定したポート[フォワ](http://d.hatena.ne.jp/keyword/%A5%D5%A5%A9%A5%EF)ードにもとづき、54333を指定します。 |
| Authentication | User & Password                                              | postgresのコンテナの設定にしたがい、この認証方法を指定します。                                                                  |
| User           | postgres                                                     | database.ymlで定義した内容に従って、postgresを指定します                                                                        |
| Password       | \<空欄\>                                                     | docker-compose.ymlで指定した内容にて、パスワード不要のオプションを設定しているため、空欄にします                                |
| Database       | sample\_[rails](http://d.hatena.ne.jp/keyword/rails)\_app_db | database.ymlで指定した内容に基づき、この名前のDBへの接続を指定します                                                            |

入力が完了したら、TestConnectionを行い、問題なければOKを押してください。

<img alt="f:id:ikmbear:20211115191635p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115191635.png" title="" height="398" width="298" />

うまくいけばこのようにDatabaseの中身を確認することができます。

### [Rails](http://d.hatena.ne.jp/keyword/Rails)アプリケーションの実行

<img alt="f:id:ikmbear:20211115191735p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115191735.png" title="" height="33" width="306" />

[ツールバー](http://d.hatena.ne.jp/keyword/%A5%C4%A1%BC%A5%EB%A5%D0%A1%BC)の実行対象に「DEVELOPMENT:SAMPLE\_[RAILS](http://d.hatena.ne.jp/keyword/RAILS)\_APP」を指定し、再生ボタンを押します。

<img alt="f:id:ikmbear:20211115191943p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115191943.png" title="" height="697" width="1152" />

ブラウザを開き、`http://0.0.0.0:3000/`にアクセスするとサンプルアプリが起動します。

なおターミナルから実行する場合は以下のようにします。

```
$ docker-compose exec web bash$ bin/rails s -b 0.0.0.0
```

### バインドマウントがされているか確認してみる

後述のdocker-composeの設定で、node_modulesを除くすべてのファイルの変更がコンテナ上に反映されます。  
実際にソースを少し改変して、反映されることを確認してみましょう。

`app/views/static_pages/home.html.erb`を開き、23行目にある内容を書き換えてみましょう。

```
    <h2>      BindMountTest      This is the home page for the      <a href="https://www.railstutorial.org/">Ruby on Rails Tutorial</a>      sample application.    </h2>
```

この状態でアプリをリロードします。

<img alt="f:id:ikmbear:20211115192819p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115192819.png" title="" height="209" width="635" />

たしかに内容が変更されていることが確認できました。

## 定義ファイルを確認する

ここまでで実際に[Rails](http://d.hatena.ne.jp/keyword/Rails)アプリを立ち上げることができました。ここからはこの環境を作成した定義ファイルを確認していきたいと思います。

### docker-compose.yml

まずは`docker-compose.yml`からです。

```
version: '3'services:  db:    image: postgres    volumes:      - ./tmp/db:/var/lib/postgresql/data    environment:      POSTGRES_HOST_AUTH_METHOD: trust    ports:      - "54333:5432"  web:    build: .    command: tail -f /dev/null    volumes:      - .:/sample_rails_application      - /sample_rails_application/node_modules    ports:      - "3000:3000"      # Ports required for debugging      - "1234:1234"      - "26166:26168"    depends_on:      - db
```

順番に見ていきます。

```
version: '3'
```

これは使用するDocker Composeのバージョンを指定しているだけです。  
今回はバージョン3を指定しています。

```
services:  db:    # 略  web:    # 略
```

次にservices、つまり使用するコンテナの設定です。今回はdbというコンテナとwebというコンテナの2種類を立てます。  
順を追ってみてみましょう。まずはdbコンテナです。

```
  db:    image: postgres    volumes:      - ./tmp/db:/var/lib/postgresql/data    environment:      POSTGRES_HOST_AUTH_METHOD: trust    ports:      - "54333:5432"
```

以下各定義内容の説明です。

| 定義             | 意味                                                                                                                                                                                                                                                                                                                                                                                        |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `image:postgres` | dbコンテナでは[postgresql](http://d.hatena.ne.jp/keyword/postgresql)をイメージとします                                                                                                                                                                                                                                                                                                      |
| `volumes`        | `docker-compose.yml`からみた[相対パス](http://d.hatena.ne.jp/keyword/%C1%EA%C2%D0%A5%D1%A5%B9)で`var/lib/postgresql/data`が呼び出されたら、ホストの`./tmp/db`に読み取り、書き込みを行います。これによりデータが永続化できます                                                                                                                                                               |
| `environment`    | [環境変数](http://d.hatena.ne.jp/keyword/%B4%C4%B6%AD%CA%D1%BF%F4)として、`POSTGRES_HOST_AUTH_METHOD`を定義し、その値に`trust`を指定します。このオプションは[Postgresql](http://d.hatena.ne.jp/keyword/Postgresql)のパスワードが不要になるもので、推奨はされていません（今回は検証用の[チュートリアル](http://d.hatena.ne.jp/keyword/%A5%C1%A5%E5%A1%BC%A5%C8%A5%EA%A5%A2%A5%EB)なので...） |
| `ports`          | ホストのポート54333を5432にポート[フォワ](http://d.hatena.ne.jp/keyword/%A5%D5%A5%A9%A5%EF)ードします。                                                                                                                                                                                                                                                                                     |

`volumes`の指定は、Dockerの2つある方法のうちの「バインドマウント（Dockerエンジン上ではなく、ホストの指定した箇所に保存する）」の指定で、`:`を境にホスト:コンテナのように指定されています。

参考：[Postgres - Official Image | Docker Hub](https://hub.docker.com/_/postgres)

続いてwebコンテナを確認します。

```
  web:    build: .    command: tail -f /dev/null    volumes:      - .:/sample_rails_application      - /sample_rails_application/node_modules    ports:      - "3000:3000"      # Ports required for debugging      - "1234:1234"      - "26166:26168"    depends_on:      - db
```

こちらも同様に各定義内容の説明です。

| 定義         | 意味                                                                                                                                                                                                                                                                                                                                                 |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `build`      | `docker-compose`から見た[相対パス](http://d.hatena.ne.jp/keyword/%C1%EA%C2%D0%A5%D1%A5%B9)で`.`つまり、カレント[ディレクト](http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8)リにあるDockerfileをベースにしてコンテナを作成します。                                                                                                      |
| `command`    | コンテナ起動時のコマンドを指定する。`tail -f /dev/null`は何もしないで起動を続けるためのコマンドで、RubyMine側で[Rails](http://d.hatena.ne.jp/keyword/Rails)を起動する際に、コンテナ内で[Rails](http://d.hatena.ne.jp/keyword/Rails)が立ち上がっているとプロセスが重複して起動できなくなることを回避するために、このようにしています。                |
| `volumes`    | 一行目は、コンテナの`./sample_rails_application`に対して、ホストの`.`（カレント[ディレクト](http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8)リ）をバインドマウントしています。2行目はコンテナ上の`node_modules`[ディレクト](http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8)リを名前なしボリュームとしてマウントしています |
| `ports`      | ポート[フォワ](http://d.hatena.ne.jp/keyword/%A5%D5%A5%A9%A5%EF)ードを定義しています                                                                                                                                                                                                                                                                 |
| `depends_on` | dbコンテナに依存することを定義しています                                                                                                                                                                                                                                                                                                             |

結構ややこしいのが、`node_modules`の名前なしボリュームでのマウントです。  
まず先の通り、手元のソースの反映はバインドマウントによって、すべてコンテナ上と同期されます。  
こうすると、ホスト上とコンテナ上の`node_modules`がそれぞれ同期されてしまうのですが、せっかくコンテナ上で固定したnodeが、ホストによって破壊されることになってしまいます。

そのため、`node_modules`のみはバインドの対象外とするのですが、コンテナが破棄されたのちもデータを永続化するため、DockerEngine上に名前なしボリュームとしてマウントする手段をとっています。

参考：[VSCode&Docker Volumeにおけるnode_modules問題を解決する](https://zenn.dev/foolishell/articles/3d327557af3554)

ここまでに記述した内容でたしかにコンテナが起動しているかは、コマンドでも確認することができますが、RubyMineのServicesタブを使って確認することができます。

<img alt="f:id:ikmbear:20211115182514p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/i/ikmbear/20211115/20211115182514.png" title="" height="235" width="1200" />webコンテナのポート[フォワ](http://d.hatena.ne.jp/keyword/%A5%D5%A5%A9%A5%EF)ード設定を確認

### Dockerfile

つづいて、Dockerfileです。

```
# ruby2.7.2のイメージを使用するFROM ruby:2.7.2# yarnのリポジトリを追加します（apt-key add -は標準入力の内容を追加します。つまりcurlで取得した内容を追加します）RUN curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add -# teeコマンドを使ってyarnのAPTパッケージレポジトリを自分のシステムに追加しますRUN echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list# 必要なパッケージをインストールしますRUN apt-get update -qq && apt-get install -y build-essential libpq-dev nodejs postgresql-client yarn# RUN CMD ENTRYPOINT ADD COPYの際の作業ディレクトリを`/sample_rails_application`に指定RUN mkdir /sample_rails_applicationWORKDIR /sample_rails_application# 必要な初期設定系ファイルのコピーCOPY Gemfile /sample_rails_application/GemfileCOPY Gemfile.lock /sample_rails_application/Gemfile.lockCOPY package.json /sample_rails_application/package.jsonCOPY yarn.lock /sample_rails_application/yarn.lock# 初期設定系のインストールRUN gem install bundler -v '2.2.15'RUN bundle installRUN yarn install --check-files# イメージに`. /sample_rails_application`の内容を追加するCOPY . /sample_rails_application# ポート3000で通信するEXPOSE 3000
```

このimageを元に、docker-composeのwebコンテナは作成されるようです。

## 感想

素晴らしい書籍のおかげでDockerの基礎を理解できたのはよいものの、実際に[Rails](http://d.hatena.ne.jp/keyword/Rails)アプリを一から起動するとなると、ややハードルが高かったです。  
しかしながら、この[チュートリアル](http://d.hatena.ne.jp/keyword/%A5%C1%A5%E5%A1%BC%A5%C8%A5%EA%A5%A2%A5%EB)はすでに出来上がっている[リポジトリ](http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA)を使ってアプリを動かすので、その中継点として非常にちょうどいい題材だと思いました。

一点気になったのが、node_modulesはVolumeTrickを使って名前なしボリュームにマウントしているのに、Gemfileはいいのか？というところです。  
なんか同じような類なので、Gemfileもボリュームマウントした方がいい気がするんですが、その話はまた別の機会に調べようと思います。
